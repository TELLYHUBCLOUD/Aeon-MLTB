name: Deploy to Heroku

on:
  # Manual deployment trigger - available on any branch
  workflow_dispatch:
    inputs:
      USE_CONFIG_PY:
        description: "Use config.py from repository (if available)"
        required: false
        default: false
        type: boolean

      HEROKU_APP_NAME:
        description: "Heroku App name (ignored if 'Use config.py' is enabled)"
        required: false
      HEROKU_API_KEY:
        description: "Heroku API key (ignored if 'Use config.py' is enabled)"
        required: false
      HEROKU_EMAIL:
        description: "Heroku email address (ignored if 'Use config.py' is enabled)"
        required: false
      HEROKU_TEAM_NAME:
        description: "Heroku Team Name (ignored if 'Use config.py' is enabled)"
        required: false
      BOT_TOKEN:
        description: "Telegram bot token (ignored if 'Use config.py' is enabled)"
        required: false
      OWNER_ID:
        description: "Owner's telegram ID (ignored if 'Use config.py' is enabled)"
        required: false
      DATABASE_URL:
        description: "Database URL from MongoDB (ignored if 'Use config.py' is enabled)"
        required: false
      TELEGRAM_API:
        description: "Telegram API ID from https://my.telegram.org/ (ignored if 'Use config.py' is enabled)"
        required: false
      TELEGRAM_HASH:
        description: "Telegram HASH from https://my.telegram.org/ (ignored if 'Use config.py' is enabled)"
        required: false


  # Automatic deployment when requirements.txt or Dockerfile is updated
  push:
    paths:
      - 'requirements.txt'
      - 'Dockerfile'
    branches:
      - extended
      - main
      - deploy

  # Scheduled auto redeploy (runs daily at 00:00 UTC)
  # Actual deployment depends on config.py settings or last manual deployment settings
  schedule:
    - cron: '0 0 * * *'  # Daily at midnight UTC

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        # Dynamically checkout the current branch (no ref specified means current branch)

      - name: Show current branch
        run: |
          echo "Deploying from branch: ${{ github.ref_name }}"
          echo "Commit SHA: ${{ github.sha }}"
          git branch --show-current

      - name: Show deployment mode
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "🔧 Manual deployment triggered"
            echo "Use config.py: ${{ inputs.USE_CONFIG_PY }}"
            if [ "${{ inputs.USE_CONFIG_PY }}" == "true" ]; then
              echo "Priority: config.py > inputs > secrets"
            else
              echo "Priority: config.py > inputs > secrets (inputs will be validated)"
            fi
          elif [ "${{ github.event_name }}" == "schedule" ]; then
            echo "⏰ Scheduled deployment triggered"
            echo "Priority: config.py > secrets (checking auto redeploy settings)"
          else
            echo "🤖 Automatic deployment triggered by push event"
            echo "Priority: config.py > secrets (inputs ignored)"
          fi

      - name: Check config.py availability
        run: |
          if [ -f "config.py" ]; then
            echo "config.py found in repository"
            echo "CONFIG_PY_EXISTS=true" >> $GITHUB_ENV
          else
            echo "config.py not found in repository"
            echo "CONFIG_PY_EXISTS=false" >> $GITHUB_ENV
            # For manual deployment with USE_CONFIG_PY enabled, this is an error
            if [ "${{ inputs.USE_CONFIG_PY }}" == "true" ]; then
              echo "::error::config.py not found but 'Use config.py' is enabled. Please add config.py to your repository or disable the toggle."
              exit 1
            fi
            # For automatic deployment, this is just informational
            echo "config.py not available for automatic deployment, will use repository secrets"
          fi

      - name: Extract config from config.py
        if: ${{ env.CONFIG_PY_EXISTS == 'true' }}
        run: |
          python3 << 'EOF'
          import sys
          import os

          try:
              # Import config.py
              import config

              # Extract required configuration values
              configs = {
                  'BOT_TOKEN': getattr(config, 'BOT_TOKEN', ''),
                  'OWNER_ID': str(getattr(config, 'OWNER_ID', '')),
                  'DATABASE_URL': getattr(config, 'DATABASE_URL', ''),
                  'TELEGRAM_API': str(getattr(config, 'TELEGRAM_API', '')),
                  'TELEGRAM_HASH': getattr(config, 'TELEGRAM_HASH', ''),
                  'HEROKU_APP_NAME': getattr(config, 'HEROKU_APP_NAME', ''),
                  'HEROKU_API_KEY': getattr(config, 'HEROKU_API_KEY', ''),
                  'HEROKU_EMAIL': getattr(config, 'HEROKU_EMAIL', ''),
                  'HEROKU_TEAM_NAME': getattr(config, 'HEROKU_TEAM_NAME', ''),
                  'UPSTREAM_REPO': getattr(config, 'UPSTREAM_REPO', 'https://github.com/AeonOrg/Aeon-MLTB'),
                  'UPSTREAM_BRANCH': getattr(config, 'UPSTREAM_BRANCH', 'extended'),
                  'AUTO_REDEPLOY': str(getattr(config, 'AUTO_REDEPLOY', False)).lower(),
                  'REDEPLOY_INTERVAL_DAYS': str(getattr(config, 'REDEPLOY_INTERVAL_DAYS', 7)),
                  'HEROKU_REGION': getattr(config, 'HEROKU_REGION', 'eu')
              }

              # Validate required fields
              required_fields = ['BOT_TOKEN', 'OWNER_ID', 'TELEGRAM_API', 'TELEGRAM_HASH']
              missing_fields = [field for field in required_fields if not configs[field]]

              if missing_fields:
                  print(f"::error::Missing required fields in config.py: {', '.join(missing_fields)}")
                  sys.exit(1)

              # Set environment variables
              with open(os.environ['GITHUB_ENV'], 'a') as env_file:
                  for key, value in configs.items():
                      if value:  # Only set non-empty values
                          env_file.write(f"CONFIG_{key}={value}\n")
                          print(f"Set CONFIG_{key} from config.py")

              print("Successfully extracted configuration from config.py")

          except ImportError as e:
              print(f"::error::Failed to import config.py: {e}")
              sys.exit(1)
          except Exception as e:
              print(f"::error::Error reading config.py: {e}")
              sys.exit(1)
          EOF

      - name: Check scheduled deployment eligibility
        if: ${{ github.event_name == 'schedule' }}
        run: |
          echo "🔍 Checking if scheduled deployment should proceed..."

          # Check if auto redeploy is enabled in config.py or secrets
          AUTO_REDEPLOY_ENABLED="${{ env.CONFIG_AUTO_REDEPLOY || secrets.AUTO_REDEPLOY || 'false' }}"
          REDEPLOY_INTERVAL="${{ env.CONFIG_REDEPLOY_INTERVAL_DAYS || secrets.REDEPLOY_INTERVAL_DAYS || '7' }}"

          echo "Auto redeploy enabled: $AUTO_REDEPLOY_ENABLED"
          echo "Redeploy interval: $REDEPLOY_INTERVAL days"

          if [ "$AUTO_REDEPLOY_ENABLED" != "true" ]; then
            echo "❌ Auto redeploy is disabled. Skipping scheduled deployment."
            echo "SKIP_DEPLOYMENT=true" >> $GITHUB_ENV
            exit 0
          fi

          # Get the last workflow run time for this repository
          echo "✅ Auto redeploy is enabled. Checking last deployment time..."

          # For now, we'll proceed with deployment if auto redeploy is enabled
          # In a production environment, you might want to check the last deployment time
          # using GitHub API or store deployment timestamps in a file/database

          echo "🚀 Proceeding with scheduled deployment"
          echo "SKIP_DEPLOYMENT=false" >> $GITHUB_ENV

      - name: Validate required inputs
        if: ${{ github.event_name == 'workflow_dispatch' && inputs.USE_CONFIG_PY != true }}
        run: |
          # Check required fields when not using config.py
          missing_fields=()

          # Check Heroku credentials
          if [ -z "${{ inputs.HEROKU_API_KEY || secrets.HEROKU_API_KEY }}" ]; then
            missing_fields+=("HEROKU_API_KEY")
          fi
          if [ -z "${{ inputs.HEROKU_APP_NAME || secrets.HEROKU_APP_NAME }}" ]; then
            missing_fields+=("HEROKU_APP_NAME")
          fi
          if [ -z "${{ inputs.HEROKU_EMAIL || secrets.HEROKU_EMAIL }}" ]; then
            missing_fields+=("HEROKU_EMAIL")
          fi

          # Check bot configuration
          if [ -z "${{ inputs.BOT_TOKEN || secrets.BOT_TOKEN }}" ]; then
            missing_fields+=("BOT_TOKEN")
          fi
          if [ -z "${{ inputs.OWNER_ID || secrets.OWNER_ID }}" ]; then
            missing_fields+=("OWNER_ID")
          fi
          if [ -z "${{ inputs.TELEGRAM_API || secrets.TELEGRAM_API }}" ]; then
            missing_fields+=("TELEGRAM_API")
          fi
          if [ -z "${{ inputs.TELEGRAM_HASH || secrets.TELEGRAM_HASH }}" ]; then
            missing_fields+=("TELEGRAM_HASH")
          fi

          if [ ${#missing_fields[@]} -gt 0 ]; then
            echo "::error::Missing required fields: ${missing_fields[*]}"
            echo "Please provide these values as inputs or repository secrets, or enable 'Use config.py' toggle."
            exit 1
          fi

          echo "All required fields are provided"

      - name: Delete unnecessary directories and files
        run: |
          # Directories to delete
          for dir in bot qBittorrent docs web; do
            if [ -d "./$dir" ]; then
              echo "Deleting directory: $dir"
              rm -rf ./$dir
            else
              echo "Directory not found: $dir"
            fi
          done

          # Delete aria-nox-nzb.sh if it exists
          if [ -f "./aria-nox-nzb.sh" ]; then
            echo "Deleting file: aria-nox-nzb.sh"
            rm -f ./aria-nox-nzb.sh
          else
            echo "File not found: aria-nox-nzb.sh"
          fi

      - name: Deploy to Heroku
        if: ${{ env.SKIP_DEPLOYMENT != 'true' }}
        uses: 5hojib/heroku-deploy-action@v2
        with:
          # Manual deployment: config.py > inputs > secrets
          # Automatic/Scheduled deployment: config.py > secrets
          heroku_api_key: ${{ github.event_name == 'workflow_dispatch' && (env.CONFIG_HEROKU_API_KEY || inputs.HEROKU_API_KEY || secrets.HEROKU_API_KEY) || (env.CONFIG_HEROKU_API_KEY || secrets.HEROKU_API_KEY) }}
          heroku_app_name: ${{ github.event_name == 'workflow_dispatch' && (env.CONFIG_HEROKU_APP_NAME || inputs.HEROKU_APP_NAME || secrets.HEROKU_APP_NAME) || (env.CONFIG_HEROKU_APP_NAME || secrets.HEROKU_APP_NAME) }}
          heroku_email: ${{ github.event_name == 'workflow_dispatch' && (env.CONFIG_HEROKU_EMAIL || inputs.HEROKU_EMAIL || secrets.HEROKU_EMAIL) || (env.CONFIG_HEROKU_EMAIL || secrets.HEROKU_EMAIL) }}
          team: ${{ github.event_name == 'workflow_dispatch' && (env.CONFIG_HEROKU_TEAM_NAME || inputs.HEROKU_TEAM_NAME || secrets.HEROKU_TEAM_NAME || '') || (env.CONFIG_HEROKU_TEAM_NAME || secrets.HEROKU_TEAM_NAME || '') }}
          usedocker: true
          docker_heroku_process_type: web
          stack: "container"
          region: ${{ env.CONFIG_HEROKU_REGION || secrets.HEROKU_REGION || 'eu' }}
        env:
          # Manual deployment: config.py > inputs > secrets
          # Automatic/Scheduled deployment: config.py > secrets
          HD_OWNER_ID: ${{ github.event_name == 'workflow_dispatch' && (env.CONFIG_OWNER_ID || inputs.OWNER_ID || secrets.OWNER_ID) || (env.CONFIG_OWNER_ID || secrets.OWNER_ID) }}
          HD_TELEGRAM_API: ${{ github.event_name == 'workflow_dispatch' && (env.CONFIG_TELEGRAM_API || inputs.TELEGRAM_API || secrets.TELEGRAM_API) || (env.CONFIG_TELEGRAM_API || secrets.TELEGRAM_API) }}
          HD_TELEGRAM_HASH: ${{ github.event_name == 'workflow_dispatch' && (env.CONFIG_TELEGRAM_HASH || inputs.TELEGRAM_HASH || secrets.TELEGRAM_HASH) || (env.CONFIG_TELEGRAM_HASH || secrets.TELEGRAM_HASH) }}
          HD_DATABASE_URL: ${{ github.event_name == 'workflow_dispatch' && (env.CONFIG_DATABASE_URL || inputs.DATABASE_URL || secrets.DATABASE_URL) || (env.CONFIG_DATABASE_URL || secrets.DATABASE_URL) }}
          HD_BOT_TOKEN: ${{ github.event_name == 'workflow_dispatch' && (env.CONFIG_BOT_TOKEN || inputs.BOT_TOKEN || secrets.BOT_TOKEN) || (env.CONFIG_BOT_TOKEN || secrets.BOT_TOKEN) }}
          HD_HEROKU_APP_NAME: ${{ github.event_name == 'workflow_dispatch' && (env.CONFIG_HEROKU_APP_NAME || inputs.HEROKU_APP_NAME || secrets.HEROKU_APP_NAME) || (env.CONFIG_HEROKU_APP_NAME || secrets.HEROKU_APP_NAME) }}
          HD_HEROKU_API_KEY: ${{ github.event_name == 'workflow_dispatch' && (env.CONFIG_HEROKU_API_KEY || inputs.HEROKU_API_KEY || secrets.HEROKU_API_KEY) || (env.CONFIG_HEROKU_API_KEY || secrets.HEROKU_API_KEY) }}
          HD_UPSTREAM_REPO: ${{ env.CONFIG_UPSTREAM_REPO || secrets.UPSTREAM_REPO || 'https://github.com/AeonOrg/Aeon-MLTB' }}
          HD_UPSTREAM_BRANCH: ${{ env.CONFIG_UPSTREAM_BRANCH || secrets.UPSTREAM_BRANCH || 'extended' }}
